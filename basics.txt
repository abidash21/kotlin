#Entry pointd: main function

fun main(){
    println("Abinash Dash");
}

#variables:
1.val - Immutable
2.var - Mutable


#lateinit
Initialize vairable later
ex: lateinit var name: String
    name = "Abinash"
(val can not be used)

#Datatype
1. Numeric:
   Byte - 8 bit
   Short - 16 bit
   Int - 32 bit
   Long - 64 bit
   Float - 32 bit floating point num(suffix f)
   Double - 64 bit floating point num

2. Character and String
   Char
   String

3. Boolean:
   TRUE/FALSE

4.Array Data Type

    val numbers = arrayOf(1,2,3,4);
    println(numbers[0]);
    println("First Number: ${numbers[2]}");
    val Numbers : Array<Int> = arrayOf(5,6,7,8); //TypeSafe
    println(Numbers[1]);
    val mixedArray = arrayListOf("Hello", 10, true);
    println(mixedArray.joinToString(
     separator = " | ",
    prefix = "[",
    postfix = "]"
    ));


5.Nullable Datatype
   =>variables by default can't hold null variables
   =>var name: String? = null;

#Standad Input
fun main() {
    var name = readln()
    println(name);
}

#Collections
 store and manipulate groups of Data

 There are two main types of Collections:
 1. Immutable(Read-only)
 List<T> -> Ordered Collection (duplicates allowed)
 Set<T> -> Unique elements (unordered)
 Map<K,V> -> Key-Value pairs (unique keys)

 2. Mutable(Modified)
MutableList<T> -> Ordered Collection (duplicates allowed)
MutableSet<T> -> Unique elements (unordered)
MutableMap<K,V> -> Key-Value pairs (unique keys)

ex: val fruits = mutableListOf("Apple","Banana","Cherry","Orange")
    val mp = mutableMapOf("shivam" to 108,"vijay" to 501,"Three" to 3)
    println(mp)


#If as an expression
    val max = if (a>b) a else b

#When
    val day=readln().toInt()
    when(day){
        1-> println("Monday");
        2-> println("Tuesday");
        3-> println("Wednesday");
        4-> println("Thursday");
        5-> println("Friday");
        6,7 -> println("Weekend");
        else -> println("Invalid day");
    }

    "->" separates condtion from the result

#Loop
1.for(variable in range/collection)
  iterate over range,array,list and any iterable object
   for (i in 1..5) println(i);

2.while (condition){
    //code execute until condition true
}

#Nullsafety 
handle nullable data type
4 pointers handle null pointer exception
1. (?.) - safe call exception
   Access properties or null methods safely
   if variable is null, it returns null

   var name: String? = null;
   println(name?.length);

2. (?:) - elvis operator
   Provide a default value when value is null.

ex: var name: String? = null
    val finalName = name ?: "Unknown"
    println(finalName) 

    - When left side is null, the right side expression is returned

3. (!!) - Not null assertion operator
   forcefully converts a nullable type to a non-nullable type 
   and throws a NullPointerException if the value is actually null

   ex: var name: String? = null
       val length = name!!.length   // ‚ùå Throws NullPointerException

    - Avoid using !! unless you are 100% sure the value cannot be null.

4. (as?) - safe cast operator
   Safetly cast a variable to target type
   if casting fails throws null

   val obj: Any = "Abinash"
   val name= obj as? Int  //prints null
   val name= obj as? String  //prints Abinash
   val name= obj as Int  //Throws class exception
   val name= obj as String  // prints Abinash

# use of let with safe call operator
   let function is used to execute a block of code only if the variable is not null.
   Used with nullable types to avoid null pointer exception
   ex:
   var name: String? = "Abinash"

   name?.let {
    println(name); // executes only if name is not null
   }

# Functions
  
1. Main function(entry point)
   fun main(){

   }

2. User defined functions
   fun greet(){
    println("Good Morning");
   }

3. parameterized functions
   fun green(name: String, age: Int){
    println("Hello, $name,You are $age years old.");
   }

4. Unit returning functions - a function that doesn't return a value(similar to void)
   fun run(): Unit {
    println("I am running");
   }

5. Single expression function
   fun square(n: Int): Int{
      return n*n;
   }  // normal function

   fun square (n: Int) = n*n;

6. Generic Function(can work with any type of data)
   fun <T> printData(data: T){
    println("Data: $data");
   }

7. Lambda Function
   A function without a name, that can be assigned a variable

   =>val lamdbaName: (inputType) -> ReturnType = { parameter ->() body} // {}-lamda expression

   =>If the lambda has only one parameter, you can use the default name it
    val square: (Int) -> Int = { it * it }
   
   =>val numbers = listOf(1, 2, 3, 4, 5)
     val doubled = numbers.map { it * 2 }



8. High Order Function
   A function that takes another function as a parameter or returns one
   ex:
    fun greet(name: String, action: (String) -> String): String {
      return action(name)
    }

    fun main(){
      val message = greet("Abinash"){name -> "Hi, $name"};
      println(message)
    }

9. Member Function - A function inside the class
   
   class Person(val name: String){
    fun introduce(){
        println("Hi, $name");
    }
   }
   fun main(){
      val p=Person("Abinash")
      p.introduce();
   }

10. Overriding Function - used in inheritance
    
    // By default classes are final - which means it can not be inherited
    open class Animal{
      open fun makeSound(){
      }
    }

   class Dog: Animal(){
    override fun makeSound(){
        println("Dog Barks");
     }
   }
   fun main(){
     val myDog = Dog();
     myDog.makeSound();
    }

#Interface
=> an interface in kotlin is a blueprint of a class that defines what a class should do 
   not how to do it(similar to abstract class)
=> provides method declaration(can have implemetations)
=> class can implement multiple interfaces
=> multiple inheritance is not allowed

interface Animal{
    fun makeSound()
}

class Dog: Animal {
    override fun makeSound(){
        println("Barking").
    }
}

fun main(){
    val dog = Dog();
    dog.makeSound();
}
 
=> If a function is implemented in the interface then it is default
=> Handling conflicts in interface

interface A{
    fun show(){
        println("interface A");
    }
}

interface B{
    fun show(){
        println("interface A");
    }
}

class C: A,B{
    override fun show(){
        super<A>.show();
    }
}

fun main(){
    var obj = C();
    obj.show();
}

#class
=>blueprint for creating objects
=>defines properties and methods
#object
=>Instance of a class,access class properties and properties

#constructor
=>special function used to Initialize a class when object is created

1. Primary constructor
=>A primary header is declared in the class header using the constructor

2. Secondary constructor
=>declared within the class body using constructor keyword

3. Init Block(for extra initialization)
=>The init block is executed as soon as the object is created, before any other
  function run even before constructor.

  class Car(brand: String, model: String){
    init {
        println("Car $brand and $model is created");
    }
  }


#Types of class
1. Data class
   Used to store data and provides some useful methods like toString(),copy() etc.

   data class User(val name: String, val age: Int)


   fun main() {
      val u1 = User("Abinash",23)
      println(u1)
      val u2=u1.copy(age=25);
      println(u2)
    }

2. Enum class
   To define a class of constant values

3. Sealed class
   similar to enum but with more flexibility,used for defining restricted hierarchies.


sealed class Result

class Success(val Data: String): Result();
class Error(val message: String): Result();

fun handle(result: Result){
    when (result){
        is Success -> println(result.Data)
        is Error -> println(result.message)
    }
}

fun main(){
    var r1 = Success("Successfully logged")
    handle(r1)
}

4. Abstract class
=>Abstract class can not be instantiated and must be inherited
=>Abstract keyword must be used before function declaring
  and it must be override in child classes


5. Singleton object
=>Class that can have only one instance
=>keyword object is used to create a Singleton
=>can access it directly without creating instance

